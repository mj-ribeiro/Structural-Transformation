p*rowSums(M)
M
diag(2)*P%*%rowSums(M)
diag(2)*P%*%rowSums(M).T
diag(2)*P%*%t(rowSums(M) )
diag(2)*P
M
rowSums(M)
t(rowSums(M))
diag(2)*P
diag(2)*P%*% matrix(rowSums(M), ncol = 1)
matrix(rowSums(M), ncol = 1)
diag(2)*P
diag(2)*P%*% matrix(rowSums(M), ncol = 1)
diag(2)*P%*% matrix(rowSums(M), ncol = 1)
diag(2)*P%*% matrix(rowSums(M), ncol = 1)
diag(2)*P%*% matrix(rowSums(M), ncol = 1)
matrix(rowSums(M), ncol = 1)
diag(2)*P%*% matrix(rowSums(M), nrow = 1)
(diag(2)*P)%*% matrix(rowSums(M), ncol = 1)
p*rowSums(M)
p
p*p
(diag(2)*P)%*%(diag(2)*P)
(diag(2)*P)%*%(P)
(diag(2)%*%P)%*%(P)
diag(2)%*%P
p*p
(diag(2)%*%P)%*%(P)
p1 = matrix(c(1, 2), nrow = 2)
p2 = matrix(c(3, 4), nrow = 2)
p1*p2
diag(2)%*%p1
diag(2)%*%p1%*%p2
diag(2)%*%p1%*%t(p2)
diag(diag(2)%*%p1%*%t(p2) )
diag(diag(2)%*%p1%*%t(p2))
p1 = matrix(c(11, 2), nrow = 2)
p2 = matrix(c(31, 4), nrow = 2)
p1*p2
diag(diag(2)%*%p1%*%t(p2))
p1 = matrix(c(11, 0), nrow = 2)
p2 = matrix(c(31, 1), nrow = 2)
p1*p2
diag(diag(2)%*%p1%*%t(p2))
p1 = matrix(c(2, 0), nrow = 2)
p2 = matrix(c(-1, 1), nrow = 2)
p1*p2
diag(diag(2)%*%p1%*%t(p2))
o1
p1
p1*2
p2 = matrix(c(-1, 1), nrow = 2)
p1 = matrix(c(2, 1), nrow = 2)
p1*2
diag(2)%*%p1
diag(2)%*%p1%*%2
p1*2
p1 = matrix(c(2, 3), nrow = 2)
p1*2
diag(2)%*%p1%*%2
p1 = matrix(c(-12, 30), nrow = 2)
p1*2
diag(2)%*%p1%*%2
P =  matrix(c(1, 2, 1, 0), nrow = 2)
P
p1
p2
P*p2
P*cbind(p2, p2)
cbind(p2, p2)
p2
cbind(p2, p2)
P*cbind(p2, p2)
P
p2
P*cbind(p2, p2)[1]
P*cbind(p2, p2)[1,]
diag(2)%*%P%*%p2
diag(2)%*%P
diag(2)%*%P%*%p2
diag(2)%*%P%*%t(p2)
diag(2)%*%P
(diag(2)%*%P)%*%p2
t(diag(2)%*%P)%*%p2
t(diag(2)%*%P)
(diag(2)%*% t(P))%*%p2
(diag(2)%*% t(P))
(diag(2)%*% t(P))%*%cbind(p2, p2)
P*cbind(p2, p2)
(diag(2)%*% t(P))%*%p2
t(p2)
P*p2
P*cbind(p2, p2)
rowSums(P*cbind(p2, p2) )
P%*%p2
colSums(P*cbind(p2, p2) )
P%*%p2
P =  matrix(c(1, 2, 1, 0), nrow = 2)
p2 = matrix(c(-1, 1), nrow = 2)
rowSums(P*cbind(p2, p2) )
P%*%p2
P%*%diag(p2)
diag(p2)
p2
I
P%*%
I
P%*%
I(2)
matrix(c(1, 0, 1, 0), nrow = 2)
I = matrix(c(1, 0, 0, 1), nrow = 2)
I
P%*%(I*p2)
P%*%(I*cbind(p2, p2))
rowSums(P*cbind(p2, p2) )
(I*cbind(p2, p2))
t(P)%*%(I*cbind(p2, p2))
rowSums(P*cbind(p2, p2) )
(P)%*%(I*cbind(p2, p2))
(I*cbind(p2, p2))
P =  matrix(c(1, 2, 1, 0), nrow = 2)
p2 = matrix(c(-1, 1), nrow = 2)
I = matrix(c(1, 0, 0, 1), nrow = 2)
rowSums(P*cbind(p2, p2) )
(P)%*%(I*cbind(p2, p2))
# Criar uma matriz diagonal com os elementos de p2
D_L = diag(p2)
# Produto matricial correto
result = P %*% D_L
diag(p2)
P%*%diag(p2)
P*diag(p2)
rowSums(P*cbind(p2, p2) )
I*cbind(p2, p2)
(P)%*%(I*cbind(p2, p2))
I*cbind(p2, p2)
P%*%(I*cbind(p2, p2))
rowSums(P*cbind(p2, p2) )
colSums(P*cbind(p2, p2) )
P%*%(I*cbind(p2, p2))
rowSums(P*cbind(p2, p2) )
P%*%(I*cbind(p2, p2))
t(P)%*%(I*cbind(p2, p2))
rowSums(P*cbind(p2, p2) )
p1*p2
p1%>%t(p2)
p1%*%t(p2)
p1*p2
diag(p1%*%t(p2))
p1*p2
rowSums(P*cbind(p2, p2) )
diag(P%*%I*cbind(p2, p2))
rowSums(P*cbind(p2, p2) )
diag(P%*%cbind(p2, p2))
rowSums(P*cbind(p2, p2) )
cbind(p2, p2)
P
diag(P%*%cbind(p2, p2))
diag(P%*%t(cbind(p2, p2)))
rowSums(P*cbind(p2, p2) )
diag(P%*%t(cbind(p2, p2)))
P%*%t(cbind(p2, p2))
P%*%t(cbind(p2, p2))
P =  matrix(c(1, 2, 1, 0), nrow = 2)
p2 = matrix(c(-1, 1), nrow = 2)
diag( P%*%t(cbind(p2, p2)) )
P
rowSums(P*cbind(p2, p2) )
diag( P%*%t(cbind(p2, p2)) )
p2
M = matrix(c(1, 2, 4, 5), nrow = 2)
p1 = matrix(c(2, 1), nrow = 2)
p1*p2
diag(diag(2)%*%p1%*%t(p2))
P =  matrix(c(1, 2, 1, 0), nrow = 2)
p2 = matrix(c(-1, 1), nrow = 2)
I = matrix(c(1, 0, 0, 1), nrow = 2)
rowSums(P*cbind(p2, p2) )
diag( P%*%t(cbind(p2, p2)) )
p1*p2
diag(p1%*%t(p2))
Rcade::games$CustomTetris
log(1)
log(0.99998)
log(1-0.1)
log(1-0.99)
log(1-0.2)
log(1-0.2)^(1-0.2)
(1-0.2)*log(1-0.2)
exp((1-0.2)*log(1-0.2) )
print('Willian baitolão!')
for (i in 1:1e6) {
print('Willian baitolão!')
}
reticulate::repl_python()
library(readxl)
new_class <- read_excel("C:/Users/marco/Downloads/wiod_old/Marc_SectorClassification.xlsx")
View(new_class)
library(tidyverse)
wiod_old = read_excel("C:/Users/marco/Downloads/wiod_old/Marc_SectorClassification.xlsx",
sheet = 'wiod_old')
new_class %>%
left_join(., wiod_old, join_by('sector'== 'sector'))
tt=new_class %>%
left_join(., wiod_old, join_by('sector'== 'sector'))
View(tt)
View(wiod_old)
tt = new_class %>%
right_join(., wiod_old, join_by('sector'== 'sector'))
View(new_class)
Rcade::games$CustomTetris
Rcade::games$CustomTetris
library(shiny)
library(plotly)
library(quantmod)
library(curl)
library(jsonlite)
library(project1)
# Função para obter os dados do Hash Rate do Bitcoin
get_hash_rate_data = function() {
tryCatch({
url = "https://api.blockchain.info/charts/hash-rate?timespan=1year&format=json"
data = jsonlite::fromJSON(url)
timestamps = as.POSIXct(data$values[,1], origin = "1970-01-01")
hash_rates = data$values[,2]
hash_rate_data = xts(hash_rates, timestamps)
return(hash_rate_data)
}, error = function(e) {
return(NULL)
})
}
get_hash_rate_data()
df = get_hash_rate_data()
View(df)
### nova versao do codigo ###
mymodel2 = function(tt, eq, default = TRUE){
if(default == TRUE){
# nome de cada modelo
model_name = c("Manufacturing", "Agriculture",
"Mining", "Services", "Digital")
# nome das variaveis dependentes
indep_vars = c("Manufacturing", "Agriculture",
"Mining", "services", "dig_trade")
}else{
# nome de cada modelo
model_name = c('n_con_imports', 'w_con_imports', 'r_con_imports', "Digital")
# nome das variaveis dependentes
indep_vars = c('n_con_imports', 'w_con_imports',
'r_con_imports', "dig_trade")
}
n_indep = length(indep_vars)
for (i in 1:n_indep) {
# formula dinamica
formula = as.formula(paste(indep_vars[i], gsub('\n', '', eq), sep = ' '))
# estimar o modelo
#cat('Estimando o Modelo:', indep_vars[i], '\n')
assign(model_name[i],
feglm(formula,
data = tt,
family = quasipoisson(link = "log")
)
)
}## fim do loop dos modelos
### colocar os modelos em uma lista
models = list(n_con_imports, w_con_imports, r_con_imports, Digital)
# Personalizar a função htmlreg para incluir apenas o número de observações
htmlreg(models,
#file = "texreg.html",
inline.css = FALSE,
doctype = TRUE,
html.tag = TRUE,
head.tag = TRUE,
body.tag = TRUE,
custom.model.names = model_name,  # Nomes dos modelos
custom.gof.rows = list("Num. Observations" = sapply(models, nobs)),
include.aic = FALSE,
include.bic = FALSE,
include.loglik = FALSE,
include.rsquared = FALSE,
include.adjrs = FALSE,
include.nobs = FALSE,
include.deviance = FALSE,
css.cell.padding = "12px",  # Aumenta o espaço entre as colunas
add.lines = list(c(" ", " ", "Trade Flow ", " ")),  # Adiciona uma linha em branco antes do cabeçalho
cline = c(1, 2, 2)  # Adiciona uma linha horizontal acima do cabeçalho
)
}
{
diretorio = dirname(rstudioapi::getSourceEditorContext()$path)
setwd(diretorio)
source('functions.r')
library(readxl)
library(tidyverse)
}
readxl::read_xlsx('results_go_wgt.xlsx')
df = readxl::read_xlsx('results_go_wgt.xlsx')
colnames(df)
df %>%
ggplot(., aes(x =wgt_go_m,  y = wgt_go_d)) +
geom_line()
df %>%
ggplot(., aes(x =wgt_go_m,  y = wgt_go_d)) +
geom_point()
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =wgt_go_m,  y = wgt_go_d)) +
geom_point()
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =wgt_go_m,  y = wgt_go_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5)
df %>%
#filter(code != 'CHN') %>%
ggplot(., aes(x =wgt_go_m,  y = wgt_go_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =wgt_go_m,  y = wgt_go_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5)
colnames(df)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =share_lab_m,  y = share_lab_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5)
cor(df$share_lab_m, df$share_lab_d)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =share_lab_m,  y = share_lab_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5) +
geom_text(code)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =share_lab_m,  y = share_lab_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5) +
geom_text('code')
library(ggrepel)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =share_lab_m,  y = share_lab_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5) +
geom_text_repel(aes(label = code), size = 5, max.overlaps = 10) +
# correlation
cor(df$share_lab_m, df$share_lab_d)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =share_lab_m,  y = share_lab_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5) +
geom_text_repel(aes(label = code), size = 5, max.overlaps = 10)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =share_lab_m,  y = share_lab_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5) +
geom_text_repel(aes(label = code), size = 3, max.overlaps = 10)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =share_lab_m,  y = share_lab_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5) +
geom_text_repel(aes(label = code), size = 2, max.overlaps = 10)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =wgt_go_m,  y = wgt_go_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5)
df %>%
group_by(sectors) %>%
summarise(mean(tfp))
## desc stats tfp
df %>%
group_by(sectors) %>%
summarise(tfp_avg = mean(tfp))
## desc stats tfp
df %>%
group_by(sectors) %>%
summarise(tfp_avg = mean(tfp)
tfp_min = min(tfp)
## desc stats tfp
df %>%
group_by(sectors) %>%
summarise(tfp_avg = mean(tfp),
tfp_min = min(tfp)
)
## desc stats tfp
df %>%
group_by(sectors) %>%
summarise(tfp_avg = mean(tfp),
tfp_min = min(tfp),
tfp_max = max(tfp)
)
## desc stats tfp
df %>%
group_by(sectors) %>%
summarise(tfp_avg = mean(tfp),
tfp_min = min(tfp),
tfp_max = max(tfp),
tfp_sd = sd(tfp)
)
df %>%
filter(obj>0)
df %>%
filter( round(obj, 2)>0)
df %>%
filter( round(obj, 2)>0) %>%
group_by(code) %>%
mutate(
obj =  ((wgt_go_m-wgt_go_d) /wgt_go_d)^2
)
df %>%
filter( round(obj, 2)>0) %>%
group_by(code) %>%
summarise(
obj2 =  ((wgt_go_m-wgt_go_d) /wgt_go_d)^2
)
df %>%
filter( round(obj, 2)>0) %>%
group_by(code) %>%
summarise(
obj2 =  sum(((wgt_go_m-wgt_go_d) /wgt_go_d)^2)
)
df %>%
filter( round(obj, 2)>0)
df %>%
filter( round(obj, 2)>0.01) %>%
group_by(code) %>%
summarise(
obj2 =  sum(((wgt_go_m-wgt_go_d) /wgt_go_d)^2)
)
df %>%
filter(code = 'CYP')
df %>%
filter(code == 'CYP')
0.000888 -0.000148
(0.000888 -0.000148 )^2
(0.000888 -0.000148 )^2/0.000148
(0.00494 - 0.00200)^2/0.002
(0.00306 -  0.00108 )^2 / 0.00108
((0.00306 -  0.00108 ) / 0.00108 )^ 0.00108
((0.000888 -0.000148 )/0.000148)^2
## dataset
df = readxl::read_xlsx('results_go_wgt.xlsx')
{
diretorio = dirname(rstudioapi::getSourceEditorContext()$path)
setwd(diretorio)
source('functions.r')
library(readxl)
library(tidyverse)
library(ggrepel)
}
## dataset
df = readxl::read_xlsx('results_go_wgt.xlsx')
## dataset
df = readxl::read_xlsx('results_go_wgt.xlsx')
colnames(df)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =wgt_go_m,  y = wgt_go_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5)
View(df)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =share_lab_m,  y = share_lab_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5) +
geom_text_repel(aes(label = code), size = 2.5, max.overlaps = 10)
# correlation
cor(df$share_lab_m, df$share_lab_d)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =wgt_go_m,  y = wgt_go_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5)
df %>%
filter( round(obj, 2)>0.01) %>%
group_by(code) %>%
summarise(
obj2 =  sum(((wgt_go_m-wgt_go_d) /wgt_go_d)^2)
)
df %>%
filter( round(obj, 2)>0.01)
df %>%
filter( round(obj, 2)>0.01) %>%
group_by(code) %>%
summarise(
obj2 =  sum(((wgt_go_m-wgt_go_d) /wgt_go_d)^2)
)
## dataset
df = readxl::read_xlsx('results_go_wgt.xlsx')
colnames(df)
df %>%
filter(code != 'CHN') %>%
ggplot(., aes(x =wgt_go_m,  y = wgt_go_d)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, size = 0.5)
df %>%
filter( code == 'AUS') %>%
summarise(
obj2 =  sum(((wgt_go_m-wgt_go_d) /wgt_go_d)^2)
)
df %>%
filter( code == 'AUS')
0^0
